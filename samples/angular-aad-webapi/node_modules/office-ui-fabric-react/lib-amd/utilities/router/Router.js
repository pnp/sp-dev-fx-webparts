var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define(["require", "exports", "react", "../../Utilities"], function (require, exports, React, Utilities_1) {
    "use strict";
    var Router = (function (_super) {
        __extends(Router, _super);
        function Router() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Router.prototype.componentDidMount = function () {
            var _this = this;
            this._events.on(window, 'hashchange', function () { return _this.forceUpdate(); });
        };
        Router.prototype.render = function () {
            return (React.createElement("div", null, this._resolveRoute()));
        };
        Router.prototype._getPath = function () {
            var path = location.hash;
            var index = path.lastIndexOf('#');
            if (index > 0) {
                path = path.substr(0, index);
            }
            return path;
        };
        Router.prototype._resolveRoute = function (path, children) {
            var _this = this;
            path = path || this._getPath();
            children = children || this.props.children;
            var routes = React.Children.toArray(children);
            var _loop_1 = function (i) {
                var route = routes[i];
                if (_match(path, route)) {
                    var _a = route.props, component_1 = _a.component, getComponent_1 = _a.getComponent;
                    if (getComponent_1) {
                        var asynchronouslyResolved_1 = false;
                        component_1 = getComponent_1.component;
                        if (!component_1) {
                            getComponent_1(function (resolved) {
                                component_1 = getComponent_1.component = resolved;
                                if (asynchronouslyResolved_1) {
                                    _this.forceUpdate();
                                }
                            });
                        }
                        // Note: in webpack 2, this ends up always async.
                        asynchronouslyResolved_1 = true;
                    }
                    if (component_1) {
                        var componentChildren = this_1._resolveRoute(path, route.props.children || []);
                        if (componentChildren) {
                            return { value: React.createElement(component_1, { key: route.key }, componentChildren) };
                        }
                        else {
                            return { value: React.createElement(component_1, { key: route.key }) };
                        }
                    }
                    else if (getComponent_1) {
                        return { value: null };
                    }
                }
            };
            var this_1 = this;
            for (var i = 0; i < routes.length; i++) {
                var state_1 = _loop_1(i);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
            return null;
        };
        return Router;
    }(Utilities_1.BaseComponent));
    exports.Router = Router;
    function _match(currentPath, child) {
        if (child.props) {
            var path = child.props.path;
            path = path || '';
            currentPath = currentPath || '';
            return ((!path) ||
                (path.toLowerCase() === currentPath.toLowerCase()));
        }
        return false;
    }
});

//# sourceMappingURL=Router.js.map
