// @copyright Microsoft Corporation. All rights reserved.
// @file This file contains an inventory of all of our framework's polyfills.
// All webpart and application code can rely on these libraries being polyfilled by our framework.
"use strict";
// ES6 Harmony Collections Polyfill
// ES6 Harmony Collections  was added as a polyfill to provide a lightweight unobtrusive shim for
// ES2015 collections. The implementations of Map, Set, and WeakMap provided by this polyfill
// adhere to the ES2015 standard. Functions that abide by the ES2015 standard such as Map.get()
// and Set.has() are guaranteed to run in sublinear time rather than the expected constant time
// for a standard hashmap implementation. (See http://stackoverflow.com/a/31092145) The alternative
// popular library to ES6 Harmony Collections is ES6 shim. After running some samples tests, we have
// determined that ES6 Harmony Collections performs better on a larger set of operations than
// the es6-shim. (Tests were run here: https://jsperf.com/es6-shim-vs-es6-collections/2 ).
// ES6 shim is also a much larger library in size.
// https://github.com/WebReflection/es6-collections
require('es6-collections');
// ES6 Promise Polyfill
// Adds an implementation of the ES2015-Promise to the browser. The implementation is a subset
// of rsvp.js.
// (See: https://github.com/tildeio/rsvp.js) ES6 Promise is compliant with Promises/A+
// (See: https://promisesaplus.com/)
// Very useful for using Promise in the Safari/IE/Edge (already supported by Chrome/Firefox)
// https://github.com/jakearchibald/es6-promise
require('es6-promise');
// Edge has a bug in their fetch implementation, which will cause an exception to be thrown if
// there are unicode characters in the body. The issue was first found in 14.14393 and is fixed in
// the Redstone 2 build of Edge (verified with a pre-release build). Until the fix is released,
// we will fall back to the polyfill on Edge. [VSO:SPPPlat #239938]
// https://microsoft.visualstudio.com/DefaultCollection/OS/_workitems?id=8475223&fullScreen=false&_a=edit
if (navigator.userAgent.indexOf('Edge/') >= 0) {
    // Set window.fetch to undefined so whatwg-fetch polyfill will redefine it.
    window.fetch = undefined;
}
// Window.Fetch PolyFill
// Adds an implementation of the Fetch standard to the browser.
// Very useful for using the fetch api in the Safari/IE (already supported by Chrome/Firefox/Edge)
// https://github.com/github/fetch
require('whatwg-fetch');
// We don't load whatwg-fetch polyfill for Firefox because it has a native implementation, but
// (unlike Chrome) it is missing the forEach() method.  Ideally we should be using for..of
// instead of forEach(), however TypeScript won't support that syntax until version 2.0.
// As a temporary workaround, we will polyfill the missing forEach() method for Firefox.
// Discussion: https://github.com/github/fetch/issues/149
if (typeof Headers.prototype.forEach === 'undefined') {
    Headers.prototype.forEach = function (callback) {
        var iterator = this.entries();
        for (;;) {
            var entry = iterator.next();
            if (entry.done) {
                break;
            }
            // NOTE: The array returns [name,value] but the callback takes (value, name).
            callback(entry.value[1], entry.value[0]);
        }
    };
}
// TypeScript 2.0 Typings have location.origin and performance as readonly properties.
// This is a polyfill for window.location.origin, which is not supported by the IE browser
if (!window.location.origin) {
    window.location.origin = window.location.protocol // tslint:disable-line:no-any
        + '//'
        + window.location.hostname
        + (window.location.port ? ':' + window.location.port : '');
}
// IE9 doesn't support performance.now(), so we need to polyfill that
if (!window.performance) {
    window.performance = {}; // tslint:disable-line:no-any
}
if (!window.performance.now) {
    // Polyfill performance.now with a function that returns the number of milliseconds since the moduler loader loaded.
    // Not as accurate as the real performance.now() function, but as accurate as we're able to get with a polyfill.
    var pageLoadTime_1 = Date.now();
    window.performance.now = function () { return Date.now() - pageLoadTime_1; };
}

//# sourceMappingURL=FrameworkPolyfills.js.map
