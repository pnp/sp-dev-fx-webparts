name: Update Likes JSON

on:
  workflow_dispatch:
  schedule:
    # 11:00 & 23:00 UTC (~6am/6pm Toronto in winter)
    - cron: "0 11,23 * * *"

permissions:
  contents: write
  discussions: read

jobs:
  build-likes:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Docs branch
        uses: actions/checkout@v4
        with:
          ref: Docs
          fetch-depth: 1
          persist-credentials: true

      - name: Use Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Generate likes.json from Discussions reactions
        env:
          GITHUB_TOKEN: ${{ github.token }}
          OWNER: pnp
          REPO: sp-dev-fx-webparts
          CATEGORY_NAME: Likes
          TITLE_PREFIX: "sample:"
          OUTPUT_PATH: "docs/data/likes.json"
        run: |
          cat > build-likes.mjs << 'EOF'
          import fs from "node:fs";
          import path from "node:path";

          const {
            GITHUB_TOKEN,
            OWNER,
            REPO,
            CATEGORY_NAME = "Likes",
            TITLE_PREFIX = "sample:",
            OUTPUT_PATH = "docs/data/likes.json",
          } = process.env;

          function requireEnv(name, value) {
            if (!value) throw new Error(`Missing required env var: ${name}`);
            return value;
          }

          requireEnv("GITHUB_TOKEN", GITHUB_TOKEN);
          requireEnv("OWNER", OWNER);
          requireEnv("REPO", REPO);

          async function graphql(query, variables) {
            const res = await fetch("https://api.github.com/graphql", {
              method: "POST",
              headers: {
                Authorization: `bearer ${GITHUB_TOKEN}`,
                "Content-Type": "application/json",
                "User-Agent": "likes-json-generator",
              },
              body: JSON.stringify({ query, variables }),
            });

            if (!res.ok) {
              const text = await res.text();
              throw new Error(`GraphQL HTTP ${res.status}: ${text}`);
            }

            const json = await res.json();
            if (json.errors?.length) {
              throw new Error(`GraphQL errors: ${JSON.stringify(json.errors, null, 2)}`);
            }
            return json.data;
          }

          const GET_CATEGORIES = `
          query($owner:String!, $repo:String!) {
            repository(owner:$owner, name:$repo) {
              discussionCategories(first:100) {
                nodes { id name }
              }
            }
          }`;

          const GET_DISCUSSIONS_PAGE = `
          query($owner:String!, $repo:String!, $categoryId:ID!, $after:String) {
            repository(owner:$owner, name:$repo) {
              discussions(first:100, after:$after, categoryId:$categoryId, orderBy:{field:UPDATED_AT, direction:DESC}) {
                nodes {
                  title
                  url
                  number
                  reactionGroups {
                    content
                    reactors { totalCount }
                  }
                }
                pageInfo { hasNextPage endCursor }
              }
            }
          }`;

          function extractSampleName(title) {
            const t = String(title ?? "").trim();
            if (!t.toLowerCase().startsWith(TITLE_PREFIX.toLowerCase())) return null;
            const afterPrefix = t.slice(TITLE_PREFIX.length).trim();
            if (!afterPrefix) return null;
            // If you ever add extra text after the name, keep just the first token
            return afterPrefix.split(/\s+/)[0]?.trim() || null;
          }

          function thumbsUpCount(reactionGroups) {
            if (!Array.isArray(reactionGroups)) return 0;
            const grp = reactionGroups.find(g => g?.content === "THUMBS_UP");
            const count = grp?.reactors?.totalCount;
            return Number.isFinite(count) ? count : 0;
          }

          async function main() {
            const catData = await graphql(GET_CATEGORIES, { owner: OWNER, repo: REPO });
            const categories = catData?.repository?.discussionCategories?.nodes ?? [];
            const category = categories.find(c => c?.name === CATEGORY_NAME);

            if (!category?.id) {
              throw new Error(
                `Could not find discussion category named "${CATEGORY_NAME}". Available: ${categories
                  .map(c => c?.name)
                  .filter(Boolean)
                  .join(", ")}`
              );
            }

            const likes = {};
            let after = null;

            while (true) {
              const data = await graphql(GET_DISCUSSIONS_PAGE, {
                owner: OWNER,
                repo: REPO,
                categoryId: category.id,
                after,
              });

              const conn = data?.repository?.discussions;
              const nodes = conn?.nodes ?? [];

              for (const d of nodes) {
                const name = extractSampleName(d?.title);
                if (!name) continue;

                likes[name] = {
                  count: thumbsUpCount(d?.reactionGroups),
                  discussionNumber: d?.number ?? null,
                  discussionUrl: d?.url ?? null,
                };
              }

              const pageInfo = conn?.pageInfo;
              if (!pageInfo?.hasNextPage) break;
              after = pageInfo.endCursor;
            }

            const out = {
              generatedAt: new Date().toISOString(),
              source: { owner: OWNER, repo: REPO, category: CATEGORY_NAME },
              likes,
            };

            const outPath = path.resolve(process.cwd(), OUTPUT_PATH);
            fs.mkdirSync(path.dirname(outPath), { recursive: true });
            fs.writeFileSync(outPath, JSON.stringify(out, null, 2) + "\n", "utf8");

            console.log(`Wrote ${Object.keys(likes).length} entries to ${OUTPUT_PATH}`);
          }

          main().catch(err => {
            console.error(err);
            process.exit(1);
          });
          EOF

          node build-likes.mjs
          

      - name: Commit & push to Docs (if changed)
        run: |
          # Stage the generated file (use -f if you discover it's ignored)
          git add -A docs/data/likes.json

          # If nothing staged (including new files), exit cleanly
          if git diff --cached --quiet; then
            echo "No changes."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git commit -m "chore: update likes.json"
          git push origin Docs

