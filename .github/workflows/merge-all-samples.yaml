name: Merge All Samples

on:
  push:
    branches:
      - main
    paths:
      - ".metadata/samples.json"
      - ".metadata/extensions-samples.json"
  workflow_dispatch:
  schedule:
  - cron: "0 6 * * 1" # Mondays 06:00 UTC
jobs:
  merge_all_samples:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses:  actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main

      - name: Set up Python
        uses:  actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Set up Node
        uses: actions/setup-node@v4
        with: 
          node-version: "20"

      - name: Merge + slim samples files
        id: merge
        run: |
          python3 << 'EOF'
          import json
          import sys
          from pathlib import Path

          def flatten_samples(data):
              if isinstance(data, list):
                  out = []
                  for item in data:
                      if isinstance(item, dict):
                          out.append(item)
                      elif isinstance(item, list):
                          out.extend(flatten_samples(item))
                  return out
              if isinstance(data, dict):
                  return [data]
              return []

          def pick_primary_thumbnail(sample: dict):
              thumbs = sample.get("thumbnails") or []
              if not isinstance(thumbs, list):
                  return None

              images = [t for t in thumbs if isinstance(t, dict) and t.get("type") == "image" and t.get("url")]
              if not images:
                  return None

              def order_key(t):
                  o = t.get("order")
                  return o if isinstance(o, int) else 999999

              images.sort(key=order_key)
              return images[0]

          def slim_sample(sample: dict):
              primary = pick_primary_thumbnail(sample)

              # Keep only what your UI needs
              out = {
                  "name": sample.get("name"),
                  "source": sample.get("source"),
                  "title": sample.get("title"),
                  "shortDescription": sample.get("shortDescription"),
                  "url": sample.get("url"),
                  "downloadUrl": sample.get("downloadUrl"),
                  "updateDateTime": sample.get("updateDateTime"),
                  "metadata": sample.get("metadata") or [],
                  "tags": sample.get("tags") or [],
                  "categories": sample.get("categories") or [],
                  "authors": sample.get("authors") or [],
                  # Keep ONLY 1 thumbnail for the optimizer to consume
                  "thumbnails":  [primary] if primary else [],
              }

              # Explicitly dropped:
              # - creationDateTime
              # - longDescription
              # - products
              # - references
              # - extra thumbnails
              return out

          all_samples = []
          errors = []
          file_stats = {}

          base_path = Path.cwd().resolve()
          metadata_dir = base_path / ".metadata"
          metadata_dir.mkdir(parents=True, exist_ok=True)

          files_to_merge = [
              ("samples.json", "WebParts"),
              ("extensions-samples.json", "Extensions")
          ]

          print("üîÑ Merging + slimming sample files...\n")

          for filename, source_type in files_to_merge:
              file_path = metadata_dir / filename
              if not file_path.exists():
                  print(f"‚ÑπÔ∏è {filename}: File not found (skipping)")
                  file_stats[filename] = {"type": source_type, "count": 0, "status": "not_found"}
                  continue

              try:
                  content = file_path.read_text(encoding="utf-8").strip()
                  if not content: 
                      errors.append({"file": filename, "error": "Empty file"})
                      print(f"‚úó {filename}: Empty file")
                      file_stats[filename] = {"type": source_type, "count": 0, "status": "empty"}
                      continue

                  data = json.loads(content)
                  samples = flatten_samples(data)

                  if not samples:
                      errors.append({"file": filename, "error": "No valid samples found after flattening"})
                      print(f"‚úó {filename}: No valid samples found")
                      file_stats[filename] = {"type": source_type, "count": 0, "status": "no_samples"}
                      continue

                  slimmed = [slim_sample(s) for s in samples if isinstance(s, dict)]
                  all_samples.extend(slimmed)
                  print(f"‚úì {filename}: Added {len(slimmed)} {source_type} samples")
                  file_stats[filename] = {"type": source_type, "count": len(slimmed), "status": "success"}

              except json.JSONDecodeError as e:
                  errors.append({"file": filename, "error": f"JSON decode error: {str(e)}"})
                  print(f"‚úó {filename}: JSON error - {str(e)}")
                  file_stats[filename] = {"type": source_type, "count": 0, "status": "json_error"}
              except Exception as e:
                  errors.append({"file": filename, "error": f"Unexpected error: {str(e)}"})
                  print(f"‚úó {filename}: Error - {str(e)}")
                  file_stats[filename] = {"type":  source_type, "count": 0, "status": "error"}

          out_path = metadata_dir / "all-samples.json"
          try:
              out_path.write_text(json.dumps(all_samples, indent=2, ensure_ascii=False), encoding="utf-8")
              print(f"\n‚úì Successfully wrote {out_path}")
          except Exception as e:
              print(f"\n‚úó Error writing {out_path}: {str(e)}")
              sys.exit(1)

          merge_errors_file = metadata_dir / "merge-errors.json"
          if errors:
              payload = {
                  "timestamp": "${{ github.event.head_commit.timestamp }}",
                  "commit": "${{ github.sha }}",
                  "errors": errors
              }
              merge_errors_file.write_text(json.dumps(payload, indent=2, ensure_ascii=False), encoding="utf-8")
              print(f"‚ö†Ô∏è Errors written to: {merge_errors_file}")
              has_errors = "true"
          else:
              if merge_errors_file.exists():
                  merge_errors_file.unlink()
                  print("‚úì No errors.  Removed existing merge-errors.json")
              has_errors = "false"

          import os
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"has_errors={has_errors}\n")
              f.write(f"total_samples={len(all_samples)}\n")
              f.write(f"file_stats={json.dumps(file_stats)}\n")
          EOF

      - name: Install thumbnail optimizer deps
        run: |
          npm init -y >/dev/null 2>&1
          npm install sharp@latest

      - name: Optimize thumbnails + rewrite all-samples.json thumbnails
        id: thumbs
        run: |
          node << 'EOF'
          const fs = require("fs");
          const path = require("path");
          const sharp = require("sharp");

          const repo = process.env.GITHUB_REPOSITORY;
          const rawBase = `https://raw.githubusercontent.com/${repo}/refs/heads/main/.metadata/thumbs/`;

          const metadataDir = path.resolve(".metadata");
          const thumbsDir = path.join(metadataDir, "thumbs");
          fs.mkdirSync(thumbsDir, { recursive: true });

          const allSamplesPath = path.join(metadataDir, "all-samples.json");
          const samples = JSON.parse(fs.readFileSync(allSamplesPath, "utf8"));

          const manifestPath = path.join(thumbsDir, "manifest.json");
          const oldManifest = fs.existsSync(manifestPath)
            ? JSON.parse(fs.readFileSync(manifestPath, "utf8"))
            : {};

          const newManifest = {};
          const expectedFiles = new Set();
          const failedThumbs = []; // ‚Üê Track failed thumbnails

          function safeFileName(name) {
            return String(name).replace(/[^a-zA-Z0-9._-]/g, "_");
          }

          function pickThumb(sample) {
            const thumbs = Array.isArray(sample.thumbnails) ? sample.thumbnails : [];
            const img = thumbs
              .filter(t => t && t.type === "image" && typeof t.url === "string" && t.url.length > 0)
              .sort((a, b) => (a.order ??  999999) - (b.order ?? 999999))[0];

            return img || null;
          }

          async function fetchBuffer(url) {
            const res = await fetch(url, { redirect: "follow" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const ab = await res.arrayBuffer();
            return Buffer.from(ab);
          }

          async function makeThumbWebp(inputBuffer, outPath) {
            const maxWidth = 420;

            let img;
            try {
              img = sharp(inputBuffer, { animated: true, pages: 1 });
              await img.metadata();
            } catch {
              img = sharp(inputBuffer);
            }

            await img
              .resize({ width: maxWidth, withoutEnlargement: true })
              .webp({ quality: 72, effort: 4 })
              .toFile(outPath);
          }

          async function run() {
            let processed = 0;
            let skipped = 0;
            let failed = 0;

            for (const s of samples) {
              const name = s?.name;
              if (!name) continue;

              const thumb = pickThumb(s);
              const origUrl = thumb?.url;

              const fileBase = safeFileName(name);
              const outFile = `${fileBase}.webp`;
              const outPath = path.join(thumbsDir, outFile);

              expectedFiles.add(outFile);

              if (! origUrl) {
                s.thumbnails = [];
                continue;
              }

              newManifest[name] = { sourceUrl: origUrl, file: outFile };

              const prev = oldManifest[name];
              const unchanged = prev && prev.sourceUrl === origUrl && fs.existsSync(outPath);

              if (unchanged) {
                skipped++;
              } else {
                try {
                  const buf = await fetchBuffer(origUrl);
                  await makeThumbWebp(buf, outPath);
                  processed++;
                } catch (e) {
                  failed++;
                  // ‚Üê Log the failure details
                  failedThumbs.push({
                    name: name,
                    url: origUrl,
                    error:  e.message
                  });
                  console.error(`‚ùå Failed to process thumbnail for ${name}:  ${e.message}`);
                  
                  // Keep the original thumbnail URL instead of emptying
                  // s.thumbnails = []; // ‚Üê Remove this line
                  continue;
                }
              }

              const alt = thumb?.alt || s.title || "Sample thumbnail";
              s.thumbnails = [
                {
                  type: "image",
                  order: 100,
                  url: rawBase + encodeURIComponent(outFile),
                  alt
                }
              ];
            }

            // Delete orphan thumbs
            let deleted = 0;
            for (const file of fs.readdirSync(thumbsDir)) {
              if (file === "manifest.json") continue;
              if (! expectedFiles.has(file)) {
                fs.rmSync(path.join(thumbsDir, file), { force: true });
                deleted++;
              }
            }

            fs.writeFileSync(manifestPath, JSON.stringify(newManifest, null, 2), "utf8");
            fs.writeFileSync(allSamplesPath, JSON.stringify(samples, null, 2), "utf8");

            console.log(`üñºÔ∏è Thumbs processed: ${processed}, skipped: ${skipped}, failed: ${failed}`);

            // Write failed thumbnails to a file for debugging
            if (failedThumbs.length > 0) {
              const failedPath = path.join(metadataDir, "thumbnail-failures.json");
              fs.writeFileSync(failedPath, JSON.stringify(failedThumbs, null, 2), "utf8");
              console.log(`‚ö†Ô∏è Failed thumbnails written to: ${failedPath}`);
            }

            // Output for GitHub Actions
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `thumbs_processed=${processed}\n`);
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `thumbs_skipped=${skipped}\n`);
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `thumbs_failed=${failed}\n`);
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `thumbs_deleted=${deleted}\n`);
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `has_thumb_failures=${failedThumbs.length > 0 ? 'true' : 'false'}\n`);
          }

          run().catch(err => {
            console.error("Thumbnail optimization failed:", err);
            process.exit(1);
          });
          EOF

      - name: Check for changes
        id: check_changes
        run:  |
          git add .metadata/all-samples.json
          if [ -f .metadata/merge-errors.json ]; then
            git add .metadata/merge-errors.json
          fi
          if [ -d .metadata/thumbs ]; then
            git add .metadata/thumbs
          fi

          git status
          echo ""

          if git diff --cached --exit-code .metadata/; then
            echo "changes=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No changes detected"
          else
            echo "changes=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Changes detected"
          fi

      - name: Commit and push changesF
        if: steps.check_changes.outputs.changes == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          if [ "${{ steps.merge.outputs.has_errors }}" == "true" ]; then
            git commit -m "chore:  merge all samples + thumbs (with errors) [skip ci]"
          else
            git commit -m "chore: merge all samples + thumbs [skip ci]"
          fi

          git push
          echo "‚úÖ Changes committed and pushed"

      - name: Generate workflow summary
        if: always()
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          # üìä Merge All Samples Workflow Summary
          
          ## Workflow Details
          - **Triggered by**: ${{ github.event_name }}
          - **Run number**: ${{ github.run_number }}
          - **Commit**:  ${{ github.sha }}
          - **Branch**: ${{ github.ref_name }}
          
          ## üñºÔ∏è Thumbnail Optimization
          
          | Metric | Count |
          |--------|-------|
          | **Processed** | ${{ steps.thumbs.outputs.thumbs_processed }} |
          | **Skipped (cached)** | ${{ steps.thumbs.outputs.thumbs_skipped }} |
          | **Failed** | ${{ steps.thumbs.outputs.thumbs_failed }} |
          | **Deleted (orphaned)** | ${{ steps.thumbs.outputs.thumbs_deleted }} |
          
          EOF
          
          if [ "${{ steps.thumbs.outputs.has_thumb_failures }}" == "true" ]; then
            echo "### ‚ö†Ô∏è Failed Thumbnails" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The following thumbnails failed to process.  See \`.metadata/thumbnail-failures.json\` for details:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            if [ -f .metadata/thumbnail-failures.json ]; then
              python3 << 'PYEOF'
          import json
          import os
          
          with open(".metadata/thumbnail-failures.json") as f:
              failures = json.load(f)
          
          with open(os.environ["GITHUB_STEP_SUMMARY"], "a") as summary:
              summary.write("| Sample | Error |\n")
              summary.write("|--------|-------|\n")
              for failure in failures:
                  summary.write(f"| {failure['name']} | {failure['error']} |\n")
          PYEOF
            fi
          fi
          
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          
          ---
          
          ${{ steps.merge.outputs.has_errors == 'true' && '‚ö†Ô∏è **Warning**:  Merge completed with errors.  Check `.metadata/merge-errors.json` for details.' || '‚úÖ **Success**: All samples merged successfully!' }}
          EOF