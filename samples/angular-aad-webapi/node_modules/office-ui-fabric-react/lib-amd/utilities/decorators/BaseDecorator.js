var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define(["require", "exports", "../../Utilities"], function (require, exports, Utilities_1) {
    "use strict";
    var BaseDecorator = (function (_super) {
        __extends(BaseDecorator, _super);
        function BaseDecorator() {
            var _this = _super.call(this) || this;
            _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);
            return _this;
        }
        /**
         * Updates the ref to the component composed by the decorator, which will also take care of hoisting
         * (and unhoisting as appropriate) methods from said component.
         *
         * Pass this method as the argument to the 'ref' property of the composed component.
         */
        BaseDecorator.prototype._updateComposedComponentRef = function (composedComponentInstance) {
            this._composedComponentInstance = composedComponentInstance;
            if (composedComponentInstance) {
                this._hoisted = Utilities_1.hoistMethods(this, composedComponentInstance);
            }
            else if (this._hoisted) {
                Utilities_1.unhoistMethods(this, this._hoisted);
            }
        };
        return BaseDecorator;
    }(Utilities_1.BaseComponent));
    exports.BaseDecorator = BaseDecorator;
});

//# sourceMappingURL=BaseDecorator.js.map
