name: Generate thumbnails
description: Optimize thumbnails + rewrite all-samples.json thumbnails (publish to Docs branch)

inputs:
  node-version:
    required: false
    default: "20"
  docs-path:
    required: false
    default: "Docs"
  all-samples-path:
    required: false
    default: ".metadata/all-samples.json"
  install-deps:
    required: false
    default: "true"

outputs:
  thumbnails_generated:
    description: Number of thumbnail files generated/updated
    value: ${{ steps.metrics.outputs.thumbnails_generated }}
  thumbnails_failed:
    description: Number of thumbnails that failed
    value: ${{ steps.metrics.outputs.thumbnails_failed }}
  samples_with_thumbnails:
    description: Number of samples that ended up with a thumbnail URL
    value: ${{ steps.metrics.outputs.samples_with_thumbnails }}

runs:
  using: composite
  steps:
    - name: Set up Node
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}

    - name: Install image optimizer deps
      if: ${{ inputs.install-deps == 'true' }}
      shell: bash
      run: |
        npm init -y >/dev/null 2>&1
        npm install sharp >/dev/null 2>&1

    - id: metrics
      name: Optimize thumbnails + rewrite all-samples.json thumbnails (publish to Docs branch)
      shell: bash
      run: |
        node << 'EOF'
        const fs = require("fs");
        const path = require("path");
        const sharp = require("sharp");

        const docsPath = process.env.DOCS_PATH || "Docs";
        const allSamplesPath = path.resolve(process.env.ALL_SAMPLES_PATH || ".metadata/all-samples.json");

        const repo = process.env.GITHUB_REPOSITORY;
        const repoName = repo.split("/")[1];
        const pagesBase = `/${repoName}/`;
        const thumbUrlBase = `${pagesBase}images/thumbnails/`;

        const samples = JSON.parse(fs.readFileSync(allSamplesPath, "utf8"));

        const thumbsDir = path.resolve(docsPath, "docs/images/thumbnails");
        fs.mkdirSync(thumbsDir, { recursive: true });

        const manifestPath = path.join(thumbsDir, "manifest.json");
        const newManifest = {};
        const expectedFiles = new Set(["manifest.json"]);

        const failedThumbs = [];
        let generatedCount = 0;
        let samplesWithThumb = 0;

        function safeFileName(name) {
          return String(name).replace(/[^a-zA-Z0-9._-]/g, "_");
        }

        function pickThumb(sample) {
          const thumbs = Array.isArray(sample.thumbnails) ? sample.thumbnails : [];
          const img = thumbs
            .filter(t => t && t.type === "image" && typeof t.url === "string")
            .find(t => t.url.length > 0);
          return img?.url || null;
        }

        async function optimizeOne(sample) {
          const thumbUrl = pickThumb(sample);
          if (!thumbUrl) return;

          // Your prior workflow logic may have supported more mapping rules.
          // Keep behavior conservative and count failures instead of crashing.
          if (thumbUrl.startsWith("http://") || thumbUrl.startsWith("https://")) {
            failedThumbs.push({ sample: sample.sample, reason: "remote_url_not_supported", url: thumbUrl });
            return;
          }

          const inputPath = path.resolve(thumbUrl);
          if (!fs.existsSync(inputPath)) {
            failedThumbs.push({ sample: sample.sample, reason: "missing_input_file", path: inputPath });
            return;
          }

          const outNameBase = safeFileName(sample.sample || sample.title || path.basename(inputPath));
          const outFile = `${outNameBase}.webp`;
          const outPath = path.join(thumbsDir, outFile);

          try {
            await sharp(inputPath)
              .resize({ width: 640, withoutEnlargement: true })
              .webp({ quality: 80 })
              .toFile(outPath);
            generatedCount += 1;
          } catch (e) {
            failedThumbs.push({ sample: sample.sample, reason: "sharp_failed", error: String(e) });
            return;
          }

          expectedFiles.add(outFile);
          newManifest[outFile] = { source: thumbUrl, sample: sample.sample };

          sample.thumbnails = [{ type: "image", url: `${thumbUrlBase}${outFile}` }];
          samplesWithThumb += 1;
        }

        (async () => {
          for (const s of samples) {
            // eslint-disable-next-line no-await-in-loop
            await optimizeOne(s);
          }

          fs.writeFileSync(allSamplesPath, JSON.stringify(samples, null, 2) + "\n");
          fs.writeFileSync(manifestPath, JSON.stringify(newManifest, null, 2) + "\n");

          // Clean old files
          for (const f of fs.readdirSync(thumbsDir)) {
            if (!expectedFiles.has(f)) {
              fs.unlinkSync(path.join(thumbsDir, f));
            }
          }

          // Outputs
          const outPath = process.env.GITHUB_OUTPUT;
          fs.appendFileSync(outPath, `thumbnails_generated=${generatedCount}\n`);
          fs.appendFileSync(outPath, `thumbnails_failed=${failedThumbs.length}\n`);
          fs.appendFileSync(outPath, `samples_with_thumbnails=${samplesWithThumb}\n`);

          // Step summary
          const summaryPath = process.env.GITHUB_STEP_SUMMARY;
          const lines = [];
          lines.push(`## Thumbnails`);
          lines.push(`- Generated/updated: **${generatedCount}**`);
          lines.push(`- Samples with thumbnail URL set: **${samplesWithThumb}**`);
          lines.push(`- Failed: **${failedThumbs.length}**`);
          if (failedThumbs.length) {
            lines.push(`\n<details><summary>Failures</summary>\n`);
            lines.push(`\n\`\`\`json\n${JSON.stringify(failedThumbs, null, 2)}\n\`\`\`\n`);
            lines.push(`</details>\n`);
          }
          fs.appendFileSync(summaryPath, lines.join("\n") + "\n");

          console.log(`Thumbnails generated into: ${thumbsDir}`);
        })().catch(err => {
          console.error(err);
          process.exit(1);
        });
        EOF
      env:
        DOCS_PATH: ${{ inputs.docs-path }}
        ALL_SAMPLES_PATH: ${{ inputs.all-samples-path }}
