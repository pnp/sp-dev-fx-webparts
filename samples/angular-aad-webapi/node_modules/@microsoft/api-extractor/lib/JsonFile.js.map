{"version":3,"sources":["JsonFile.ts"],"names":[],"mappings":"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","file":"JsonFile.js","sourcesContent":["import * as fsx from 'fs-extra';\r\nimport * as os from 'os';\r\nimport * as jju from 'jju';\r\nimport Validator = require('z-schema');\r\n\r\nexport type ValidateErrorCallback = (errorDescription: string) => void;\r\n\r\n/**\r\n * Utilities for reading/writing JSON files.\r\n */\r\nexport default class JsonFile {\r\n\r\n  public static validateSchema(jsonObject: Object, jsonSchemaObject: Object,\r\n    errorCallback: ValidateErrorCallback): void {\r\n\r\n    // Remove the $schema reference that appears in the configuration object (used for IntelliSense),\r\n    // since we are replacing it with the precompiled version.  The validator.setRemoteReference()\r\n    // API is a better way to handle this, but we'd first need to publish the schema file\r\n    // to a public web server where Visual Studio can find it.\r\n    // tslint:disable-next-line:no-string-literal\r\n    delete jsonSchemaObject['$schema'];\r\n\r\n    const validator: Validator = new Validator({\r\n      breakOnFirstError: false,\r\n      noTypeless: true\r\n    });\r\n\r\n    if (!validator.validate(jsonObject, jsonSchemaObject)) {\r\n      const errorDetails: Validator.SchemaErrorDetail[] = validator.getLastErrors();\r\n\r\n      let buffer: string = 'JSON schema validation failed:';\r\n\r\n      buffer = JsonFile._formatErrorDetails(errorDetails, '  ', buffer);\r\n      errorCallback(buffer);\r\n    }\r\n  }\r\n\r\n  public static loadJsonFile(jsonFilename: string): {} {\r\n    if (!fsx.existsSync(jsonFilename)) {\r\n      throw new Error(`Input file not found: ${jsonFilename}`);\r\n    }\r\n\r\n    const buffer: Buffer = fsx.readFileSync(jsonFilename);\r\n    try {\r\n      return jju.parse(buffer.toString());\r\n    } catch (error) {\r\n      throw new Error(`Error reading \"${jsonFilename}\":` + os.EOL + `  ${error.message}`);\r\n    }\r\n  }\r\n\r\n  public static saveJsonFile(jsonFilename: string, jsonData: {}): void {\r\n    JsonFile._validateNoUndefinedMembers(jsonData);\r\n    const stringified: string = JSON.stringify(jsonData, undefined, 2) + '\\n';\r\n    const normalized: string = JsonFile._getAllReplaced(stringified, '\\n', '\\r\\n');\r\n    fsx.writeFileSync(jsonFilename, normalized);\r\n  }\r\n\r\n  /**\r\n   * Used to validate a data structure before writing.  Reports an error if there\r\n   * are any undefined members.\r\n   */\r\n  // tslint:disable-next-line:no-any\r\n  private static _validateNoUndefinedMembers(json: any): void {\r\n    if (!json) {\r\n      return;\r\n    }\r\n    if (typeof json === 'object') {\r\n      for (const key of Object.keys(json)) {\r\n        // tslint:disable-next-line:no-any\r\n        const value: any = json[key];\r\n        if (value === undefined) {\r\n          throw new Error(`The key \"${key}\" is undefined`);\r\n        }\r\n        JsonFile._validateNoUndefinedMembers(value);\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  private static _formatErrorDetails(errorDetails: Validator.SchemaErrorDetail[], indent: string,\r\n    buffer: string): string {\r\n    for (const errorDetail of errorDetails) {\r\n      buffer += os.EOL + indent + `Error: ${errorDetail.path}`;\r\n      buffer += os.EOL + indent + `       ${errorDetail.message}`;\r\n\r\n      if (errorDetail.inner) {\r\n        buffer = JsonFile._formatErrorDetails(errorDetail.inner, indent + '  ', buffer);\r\n      }\r\n    }\r\n    return buffer;\r\n  }\r\n\r\n  /**\r\n   * Returns the same thing as targetString.replace(searchValue, replaceValue), except that\r\n   * all matches are replaced, rather than just the first match.\r\n   * @param targetString  The string to be modified\r\n   * @param searchValue   The value to search for\r\n   * @param replaceValue  The replacement text\r\n   */\r\n  private static _getAllReplaced(targetString: string, searchValue: string, replaceValue: string): string {\r\n    return targetString.split(searchValue).join(replaceValue);\r\n  }\r\n}\r\n"],"sourceRoot":"..\\src"}