"use strict";
var KeyCodes;
(function (KeyCodes) {
    KeyCodes[KeyCodes["Enter"] = 13] = "Enter";
    KeyCodes[KeyCodes["Escape"] = 27] = "Escape";
    KeyCodes[KeyCodes["Tab"] = 9] = "Tab";
    KeyCodes[KeyCodes["F10"] = 121] = "F10";
    KeyCodes[KeyCodes["P"] = 80] = "P";
})(KeyCodes = exports.KeyCodes || (exports.KeyCodes = {}));
function isEscape(e) {
    return isKey(KeyCodes.Escape, e);
}
exports.isEscape = isEscape;
function isEnter(e) {
    return isKey(KeyCodes.Enter, e);
}
exports.isEnter = isEnter;
function isShiftTab(e) {
    return isKey(KeyCodes.Tab, e, false, false, true);
}
exports.isShiftTab = isShiftTab;
function isTab(e) {
    return isKey(KeyCodes.Tab, e);
}
exports.isTab = isTab;
function isKey(keyCode, e, allowAlt, allowCtrl, allowShift) {
    if (allowAlt === void 0) { allowAlt = false; }
    if (allowCtrl === void 0) { allowCtrl = false; }
    if (allowShift === void 0) { allowShift = false; }
    return e.keyCode === keyCode &&
        ((allowAlt && e.altKey) || (!allowAlt && !e.altKey)) &&
        ((allowCtrl && e.ctrlKey) || (!allowCtrl && !e.ctrlKey)) &&
        ((allowShift && e.shiftKey) || (!allowShift && !e.shiftKey));
}
exports.isKey = isKey;
function getFocusableChildren(elem, ignoreTabIndex) {
    if (ignoreTabIndex === void 0) { ignoreTabIndex = false; }
    var children = [];
    for (var _i = 0, _a = getFocusableDescendants(elem, ignoreTabIndex); _i < _a.length; _i++) {
        var descendant = _a[_i];
        if (isElementFocusableChildOf(descendant, elem)) {
            children.push(descendant);
        }
    }
    return children;
}
exports.getFocusableChildren = getFocusableChildren;
function isElementFocusable(elem, ignoreTabIndex) {
    if (ignoreTabIndex === void 0) { ignoreTabIndex = false; }
    var tagName = elem.tagName.toLowerCase();
    if (elem
        && !elem.hidden
        && elem.offsetParent
        && window.getComputedStyle(elem).display !== 'none'
        && window.getComputedStyle(elem).visibility !== 'hidden') {
        var hasTabIndex = elem.hasAttribute('tabindex');
        var tabindex = parseInt(elem.getAttribute('tabindex'), 10);
        if (!ignoreTabIndex && hasTabIndex && tabindex < 0) {
            return false;
        }
        if (tagName === 'a' && !!elem.href ||
            elem.isContentEditable) {
            return true;
        }
        if ((tagName === 'button' ||
            tagName === 'input' ||
            tagName === 'select' ||
            tagName === 'textarea') && !elem.disabled) {
            return true;
        }
        if (ignoreTabIndex && elem.getAttribute('data-is-focusable') === 'true') {
            return true;
        }
        if (!ignoreTabIndex && hasTabIndex && tabindex > -1) {
            return true;
        }
    }
    return false;
}
exports.isElementFocusable = isElementFocusable;
function getFocusableParent(elem, topElement) {
    if (topElement === void 0) { topElement = document.body; }
    var parent = elem;
    do {
        parent = parent.parentElement;
    } while (!isElementFocusable(parent) && parent !== topElement);
    return parent;
}
exports.getFocusableParent = getFocusableParent;
function queryFocusableSelector(elem) {
    var selector = 'button,input,textarea,select,a[href]:not([href=\'\']),\
      [tabindex],[contenteditable=\'true\'], [data-is-focusable=\'true\']';
    return elem.querySelectorAll(selector);
}
function getFirstFocusableChild(elem, ignoreTabIndex) {
    if (ignoreTabIndex === void 0) { ignoreTabIndex = false; }
    var nodes = queryFocusableSelector(elem);
    for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (isElementFocusable(node, ignoreTabIndex)) {
            return node;
        }
    }
    return undefined;
}
exports.getFirstFocusableChild = getFirstFocusableChild;
function getFocusableDescendants(elem, ignoreTabIndex) {
    if (ignoreTabIndex === void 0) { ignoreTabIndex = false; }
    var descendants = [];
    var nodes = queryFocusableSelector(elem);
    for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (isElementFocusable(node, ignoreTabIndex)) {
            descendants.push(node);
        }
    }
    return descendants;
}
exports.getFocusableDescendants = getFocusableDescendants;
function getFocusableSiblings(elem, topElement) {
    if (topElement === void 0) { topElement = document.body; }
    var children = getFocusableChildren(getFocusableParent(elem, topElement));
    var siblings = [];
    var insertPointer = 0;
    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
        var child = children_1[_i];
        if (child !== elem) {
            siblings.splice(insertPointer++, 0, child);
        }
        else {
            insertPointer = 0;
        }
    }
    return siblings;
}
exports.getFocusableSiblings = getFocusableSiblings;
function getNextFocusableElement(elem, topElement) {
    if (topElement === void 0) { topElement = document.body; }
    var siblings = getFocusableSiblings(elem, topElement);
    return siblings[0];
}
exports.getNextFocusableElement = getNextFocusableElement;
function getPrevFocusableElement(elem, topElement) {
    if (topElement === void 0) { topElement = document.body; }
    var siblings = getFocusableSiblings(elem, topElement);
    return siblings[siblings.length - 1];
}
exports.getPrevFocusableElement = getPrevFocusableElement;
function isElementFocusableChildOf(elem, ancestor) {
    var parent = elem.parentElement;
    while (parent.tagName !== 'BODY') {
        if (parent !== ancestor) {
            return true;
        }
        if (isElementFocusable(parent)) {
            break;
        }
        parent = parent.parentElement;
    }
    return false;
}
exports.isElementFocusableChildOf = isElementFocusableChildOf;
function navigateInside(elem) {
    var children = getFocusableChildren(elem);
    if (children.length) {
        children[0].focus();
        return true;
    }
    else {
        return false;
    }
}
exports.navigateInside = navigateInside;
function navigateTo(elem) {
    if (isElementFocusable(elem)) {
        elem.focus();
        return true;
    }
    else {
        return navigateInside(elem);
    }
}
exports.navigateTo = navigateTo;
function navigateOutOf(elem, topElement) {
    if (topElement === void 0) { topElement = document.body; }
    topElement = topElement || document.body;
    getFocusableParent(elem, topElement).focus();
}
exports.navigateOutOf = navigateOutOf;
function ariaAlert(message) {
    var divId = 'aria_alert_' + this._randId;
    var oldAlert = document.querySelector('#' + divId);
    if (oldAlert) {
        document.body.removeChild(oldAlert);
    }
    var alertNode = document.createElement('p');
    alertNode.classList.add('Canvas-screenReaderOnly');
    alertNode.setAttribute('role', 'alert');
    alertNode.setAttribute('id', divId);
    var alertText = document.createTextNode(message);
    alertNode.appendChild(alertText);
    document.body.appendChild(alertNode);
}
exports.ariaAlert = ariaAlert;
