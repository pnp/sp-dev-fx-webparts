name: Generate thumbnails
description: Download/optimize thumbnails + rewrite all-samples.json thumbnails (publish to Docs branch)

inputs:
  node-version:
    required: false
    default: "20"
  docs-path:
    required: false
    default: "Docs"
  all-samples-path:
    required: false
    default: ".metadata/all-samples.json"
  install-deps:
    required: false
    default: "true"
  allow-remote:
    description: Allow downloading remote thumbnails (http/https)
    required: false
    default: "true"

outputs:
  thumbnails_generated:
    value: ${{ steps.metrics.outputs.thumbnails_generated }}
  thumbnails_failed:
    value: ${{ steps.metrics.outputs.thumbnails_failed }}
  samples_with_thumbnails:
    value: ${{ steps.metrics.outputs.samples_with_thumbnails }}
  thumbnails_deleted:
    value: ${{ steps.metrics.outputs.thumbnails_deleted }}

runs:
  using: composite
  steps:
    - name: Set up Node
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}

    - name: Install image optimizer deps
      if: ${{ inputs.install-deps == 'true' }}
      shell: bash
      run: |
        npm init -y >/dev/null 2>&1
        npm install sharp >/dev/null 2>&1

    - id: metrics
      name: Download/optimize thumbnails + rewrite all-samples.json thumbnails (publish to Docs branch)
      shell: bash
      run: |
        node << 'EOF'
        const fs = require("fs");
        const path = require("path");
        const os = require("os");
        const crypto = require("crypto");
        const https = require("https");
        const http = require("http");
        const sharp = require("sharp");

        const docsPath = process.env.DOCS_PATH || "Docs";
        const allSamplesPath = path.resolve(process.env.ALL_SAMPLES_PATH || ".metadata/all-samples.json");
        const allowRemote = String(process.env.ALLOW_REMOTE || "true").toLowerCase() === "true";

        const repo = process.env.GITHUB_REPOSITORY;
        const repoName = repo.split("/")[1];
        const pagesBase = `/${repoName}/`;
        const thumbUrlBase = `${pagesBase}images/thumbnails/`;

        const samples = JSON.parse(fs.readFileSync(allSamplesPath, "utf8"));

        const thumbsDir = path.resolve(docsPath, "docs/images/thumbnails");
        fs.mkdirSync(thumbsDir, { recursive: true });

        // Keep-list + orphan cleanup
        const expectedFiles = new Set(["manifest.json", ".gitkeep"].filter(f => true));
        const manifestPath = path.join(thumbsDir, "manifest.json");
        const newManifest = {};

        const failures = [];
        let generatedCount = 0;
        let samplesWithThumb = 0;
        let deletedCount = 0;

        const dlCacheDir = path.join(os.tmpdir(), "thumb-dl-cache");
        fs.mkdirSync(dlCacheDir, { recursive: true });

        function safeFileName(name) {
          return String(name).replace(/[^a-zA-Z0-9._-]/g, "_");
        }

        function sha1(input) {
          return crypto.createHash("sha1").update(String(input)).digest("hex");
        }

        function pickThumb(sample) {
          const thumbs = Array.isArray(sample.thumbnails) ? sample.thumbnails : [];
          const img = thumbs
            .filter(t => t && t.type === "image" && typeof t.url === "string")
            .find(t => t.url.length > 0);
          return img?.url || null;
        }

        function fetchToFile(url, outPath, maxRedirects = 5) {
          return new Promise((resolve, reject) => {
            const lib = url.startsWith("https://") ? https : http;
            const req = lib.get(url, {
              headers: {
                "User-Agent": "github-actions-thumbnail-bot",
                "Accept": "image/*,*/*;q=0.8"
              }
            }, (res) => {
              const status = res.statusCode || 0;

              // Redirect
              if ([301, 302, 303, 307, 308].includes(status) && res.headers.location && maxRedirects > 0) {
                const next = new URL(res.headers.location, url).toString();
                res.resume();
                return resolve(fetchToFile(next, outPath, maxRedirects - 1));
              }

              if (status < 200 || status >= 300) {
                res.resume();
                return reject(new Error(`HTTP ${status} fetching ${url}`));
              }

              const file = fs.createWriteStream(outPath);
              res.pipe(file);
              file.on("finish", () => file.close(() => resolve(outPath)));
              file.on("error", (err) => {
                try { fs.unlinkSync(outPath); } catch {}
                reject(err);
              });
            });

            req.on("error", reject);
            req.setTimeout(30000, () => {
              req.destroy(new Error(`Timeout fetching ${url}`));
            });
          });
        }

        async function resolveInputPath(thumbUrl) {
          // Remote?
          if (thumbUrl.startsWith("http://") || thumbUrl.startsWith("https://")) {
            if (!allowRemote) throw new Error("remote_disabled");

            const ext = path.extname(new URL(thumbUrl).pathname) || ".img";
            const cacheName = `${sha1(thumbUrl)}${ext}`;
            const cachedPath = path.join(dlCacheDir, cacheName);

            if (!fs.existsSync(cachedPath)) {
              await fetchToFile(thumbUrl, cachedPath);
            }
            return cachedPath;
          }

          // Local
          const localPath = path.resolve(thumbUrl);
          if (!fs.existsSync(localPath)) throw new Error(`missing_input_file:${localPath}`);
          return localPath;
        }

        async function writeWebp(inputPath, outPath) {
          await sharp(inputPath)
            .resize({ width: 420, withoutEnlargement: true })
            .webp({ quality: 80 })
            .toFile(outPath);
        }


        function outFileForSample(sample) {
          if (!sample?.name || typeof sample.name !== "string") return null;

          // Exactly like sample name; no transformation besides adding extension.
          // (We assume sample.name is already a safe filename, which it is in your data.)
          return `${sample.name}.webp`;
        }

        async function optimizeOne(sample) {
          const thumbUrl = pickThumb(sample);
          if (!thumbUrl) return;

          let inputPath;
          try {
            inputPath = await resolveInputPath(thumbUrl);
          } catch (e) {
            failures.push({ sample: sample.sample, reason: "input_unavailable", url: thumbUrl, error: String(e?.message || e) });
            return;
          }

          const outNameBase = safeFileName(sample.sample || sample.title || path.basename(inputPath));
          const outFile = outFileForSample(sample);
          if (!outFile) {
            failures.push({ reason: "missing_sample_name", sample: sample?.name ?? null, url: thumbUrl });
            return;
          }
          const outPath = path.join(thumbsDir, outFile);
          try {
            await writeWebp(inputPath, outPath);
            generatedCount += 1;
          } catch (e) {
            failures.push({ sample: sample.sample, reason: "sharp_failed", url: thumbUrl, inputPath, error: String(e?.message || e) });
            return;
          }

          expectedFiles.add(outFile);
          newManifest[outFile] = { source: thumbUrl, sample: sample.sample };

          sample.thumbnails = [{ type: "image", url: `${thumbUrlBase}${outFile}` }];
          samplesWithThumb += 1;
        }

        (async () => {
          // generate
          for (const s of samples) {
            // eslint-disable-next-line no-await-in-loop
            await optimizeOne(s);
          }

          // persist updated metadata + manifest
          fs.writeFileSync(allSamplesPath, JSON.stringify(samples, null, 2) + "\n");
          fs.writeFileSync(manifestPath, JSON.stringify(newManifest, null, 2) + "\n");

          // cleanup orphans
          for (const f of fs.readdirSync(thumbsDir)) {
            const full = path.join(thumbsDir, f);
            if (!fs.statSync(full).isFile()) continue;
            if (!expectedFiles.has(f)) {
              fs.unlinkSync(full);
              deletedCount += 1;
            }
          }

          // outputs
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `thumbnails_generated=${generatedCount}\n`);
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `thumbnails_failed=${failures.length}\n`);
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `samples_with_thumbnails=${samplesWithThumb}\n`);
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `thumbnails_deleted=${deletedCount}\n`);

          // summary
          const lines = [];
          lines.push(`## Thumbnails`);
          lines.push(`- Generated/updated: **${generatedCount}**`);
          lines.push(`- Samples with thumbnail URL set: **${samplesWithThumb}**`);
          lines.push(`- Deleted (orphans): **${deletedCount}**`);
          lines.push(`- Failed: **${failures.length}**`);
          if (failures.length) {
            lines.push(`\n<details><summary>Failures</summary>\n`);
            lines.push(`\n\`\`\`json\n${JSON.stringify(failures, null, 2)}\n\`\`\`\n`);
            lines.push(`</details>\n`);
          }
          fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, lines.join("\n") + "\n");
        })().catch(err => {
          console.error(err);
          process.exit(1);
        });
        EOF
      env:
        DOCS_PATH: ${{ inputs.docs-path }}
        ALL_SAMPLES_PATH: ${{ inputs.all-samples-path }}
        ALLOW_REMOTE: ${{ inputs.allow-remote }}
