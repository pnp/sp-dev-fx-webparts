{"version":3,"sources":["TypeScriptHelpers.ts"],"names":[],"mappings":"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","file":"TypeScriptHelpers.js","sourcesContent":["/* tslint:disable:no-bitwise */\r\n\r\nimport * as ts from 'typescript';\r\nimport PrettyPrinter from './PrettyPrinter';\r\n\r\nexport default class TypeScriptHelpers {\r\n\r\n  /**\r\n   * Splits by the characters '\\r\\n'.\r\n   */\r\n  public static newLineRegEx: RegExp = /\\r\\n|\\n/g;\r\n\r\n  /**\r\n   * Start sequence is '/**'.\r\n   */\r\n  public static jsDocStartRegEx: RegExp = /^\\s*\\/\\*\\*\\s?/g;\r\n\r\n  /**\r\n   * End sequence is '*\\/'.\r\n   */\r\n  public static jsDocEndRegEx: RegExp = /\\s*\\*\\/\\s*$/g;\r\n\r\n  /**\r\n   * Intermediate lines of JSDoc comment character.\r\n   */\r\n  public static jsDocIntermediateRegEx: RegExp = /^\\s*[*]\\s?/g;\r\n\r\n  /**\r\n   * Returns the Symbol for the provided Declaration.  This is a workaround for a missing\r\n   * feature of the TypeScript Compiler API.   It is the only apparent way to reach\r\n   * certain data structures, and seems to always work, but is not officially documented.\r\n   *\r\n   * @returns The associated Symbol.  If there is no semantic information (e.g. if the\r\n   * declaration is an extra semicolon somewhere), then \"undefined\" is returned.\r\n   */\r\n  public static tryGetSymbolForDeclaration(declaration: ts.Declaration): ts.Symbol {\r\n    /* tslint:disable:no-any */\r\n    const symbol: ts.Symbol = (declaration as any).symbol;\r\n    /* tslint:enable:no-any */\r\n    return symbol;\r\n  }\r\n\r\n  /**\r\n   * Same semantics as tryGetSymbolForDeclaration(), but throws an exception if the symbol\r\n   * cannot be found.\r\n   */\r\n  public static getSymbolForDeclaration(declaration: ts.Declaration): ts.Symbol {\r\n    const symbol: ts.Symbol = TypeScriptHelpers.tryGetSymbolForDeclaration(declaration);\r\n    if (!symbol) {\r\n      PrettyPrinter.throwUnexpectedSyntaxError(declaration,\r\n        'Unable to determine the semantic information for this declaration');\r\n    }\r\n    return symbol;\r\n  }\r\n\r\n  /**\r\n   * Returns the JSDoc comments associated with the specified node, if any.\r\n   *\r\n   * Example:\r\n   * \"This \\n is \\n a comment\" from \"\\/** This\\r\\n* is\\r\\n* a comment *\\/\r\n   */\r\n  public static getJsDocComments(node: ts.Node, errorLogger: (message: string) => void): string {\r\n    let jsDoc: string = '';\r\n    // tslint:disable-next-line:no-any\r\n    const nodeJsDocObjects: any = (node as any).jsDoc;\r\n    if (nodeJsDocObjects && nodeJsDocObjects.length > 0) {\r\n      // Use the JSDoc closest to the declaration\r\n      const lastJsDocIndex: number = nodeJsDocObjects.length - 1;\r\n      const jsDocFullText: string = nodeJsDocObjects[lastJsDocIndex].getText();\r\n      const jsDocLines: string[] = jsDocFullText.split(TypeScriptHelpers.newLineRegEx);\r\n      const jsDocStartSeqExists: boolean = TypeScriptHelpers.jsDocStartRegEx.test(jsDocLines[0].toString());\r\n\r\n      // Report error for each missing sequence seperately\r\n      if (!jsDocStartSeqExists) {\r\n        errorLogger('JsDoc comment must begin with a \\\"/**\\\" sequence.');\r\n        return '';\r\n      }\r\n      const jsDocEndSeqExists: boolean = TypeScriptHelpers.jsDocEndRegEx.test(\r\n        jsDocLines[jsDocLines.length - 1].toString()\r\n      );\r\n      if (!jsDocEndSeqExists) {\r\n        errorLogger('JsDoc comment must end with a \\\"*/\\\" sequence.');\r\n        return '';\r\n      }\r\n\r\n      jsDoc = TypeScriptHelpers.removeJsDocSequences(jsDocLines);\r\n    }\r\n\r\n    return jsDoc;\r\n  }\r\n\r\n  /**\r\n   * Helper function to remove the comment stars ('/**'. '*', '/*) from lines of comment text.\r\n   *\r\n   * Example:\r\n   * [\"\\/**\", \"*This \\n\", \"*is \\n\", \"*a comment\", \"*\\/\"] to \"This \\n is \\n a comment\"\r\n   */\r\n  public static removeJsDocSequences(textLines: string[]): string {\r\n  // Remove '/**'\r\n    textLines[0] = textLines[0].replace(TypeScriptHelpers.jsDocStartRegEx, '');\r\n    if (textLines[0] === '') {\r\n      textLines.shift();\r\n    }\r\n    // Remove '*/'\r\n    textLines[textLines.length - 1] = textLines[textLines.length - 1].replace(\r\n      TypeScriptHelpers.jsDocEndRegEx,\r\n      '');\r\n    if (textLines[textLines.length - 1] === '') {\r\n      textLines.pop();\r\n    }\r\n\r\n    // Remove the leading '*' from any intermediate lines\r\n    if (textLines.length > 0) {\r\n      for (let i: number = 0; i < textLines.length; i++) {\r\n        textLines[i] = textLines[i].replace(TypeScriptHelpers.jsDocIntermediateRegEx, '');\r\n      }\r\n    }\r\n\r\n    return textLines.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Similar to calling string.split() with a RegExp, except that the delimiters\r\n   * are included in the result.\r\n   *\r\n   * Example: _splitStringWithRegEx(\"ABCDaFG\", /A/gi) -> [ \"A\", \"BCD\", \"a\", \"FG\" ]\r\n   * Example: _splitStringWithRegEx(\"\", /A/gi) -> [ ]\r\n   * Example: _splitStringWithRegEx(\"\", /A?/gi) -> [ \"\" ]\r\n   */\r\n  public static splitStringWithRegEx(text: string, regExp: RegExp): string[] {\r\n    if (!regExp.global) {\r\n      throw new Error('RegExp must have the /g flag');\r\n    }\r\n    if (text === undefined) {\r\n      return [];\r\n    }\r\n\r\n    const result: string[] = [];\r\n    let index: number = 0;\r\n    let match: RegExpExecArray;\r\n\r\n    do {\r\n      match = regExp.exec(text);\r\n      if (match) {\r\n        if (match.index > index) {\r\n          result.push(text.substring(index, match.index));\r\n        }\r\n        const matchText: string = match[0];\r\n        if (!matchText) {\r\n          // It might be interesting to support matching e.g. '\\b', but regExp.exec()\r\n          // doesn't seem to iterate properly in this situation.\r\n          throw new Error('The regular expression must match a nonzero number of characters');\r\n        }\r\n        result.push(matchText);\r\n        index = regExp.lastIndex;\r\n      }\r\n    } while (match && regExp.global);\r\n\r\n    if (index < text.length) {\r\n      result.push(text.substr(index));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Extracts the body of a TypeScript comment and returns it.\r\n   */\r\n  // Examples:\r\n  // \"/**\\n * this is\\n * a test\\n */\\n\" --> \"this is\\na test\"\r\n  // \"/** single line comment */\" --> \"single line comment\"\r\n  public static extractCommentContent(text: string): string {\r\n    const lines: string[] = text.replace('\\r', '').split('\\n');\r\n\r\n    enum State {\r\n      Start,\r\n      Body,\r\n      Done,\r\n      Error\r\n    }\r\n    let state: State = State.Start;\r\n\r\n    const startRegExp: RegExp = /^\\s*\\/\\*\\*+ ?/;\r\n    const bodyRegExp: RegExp = /^\\s*\\* ?/;\r\n    const endRegExp: RegExp = /^\\s*\\*+\\/\\s*$/;\r\n    const singleLineEndRegExp: RegExp = / ?\\*+\\/\\s*$/;\r\n\r\n    let content: string = '';\r\n    for (const line of lines) {\r\n      if (line.trim().length === 0) {\r\n        continue;\r\n      }\r\n\r\n      let modified: string = line;\r\n      switch (state) {\r\n        case State.Start:\r\n          if (line.match(startRegExp)) {\r\n            modified = line.replace(startRegExp, '');\r\n            if (modified.match(singleLineEndRegExp)) {\r\n              modified = modified.replace(singleLineEndRegExp, '');\r\n              state = State.Done;\r\n            } else {\r\n              state = State.Body;\r\n            }\r\n          } else {\r\n            state = State.Error;\r\n          }\r\n          break;\r\n        case State.Body:\r\n          if (line.match(endRegExp)) {\r\n            modified = line.replace(endRegExp, '');\r\n            state = State.Done;\r\n          } else if (line.match(bodyRegExp)) {\r\n            modified = line.replace(bodyRegExp, '');\r\n          } else {\r\n            state = State.Error;\r\n          }\r\n          break;\r\n        case State.Done:\r\n          state = State.Error;\r\n          break;\r\n      }\r\n      if (modified !== '') {\r\n        if (content !== '') {\r\n          content += '\\n';\r\n        }\r\n        content += modified;\r\n      }\r\n    }\r\n\r\n    if (state !== State.Done) {\r\n      return '[ERROR PARSING COMMENT]';\r\n    }\r\n\r\n    return content;\r\n  }\r\n\r\n}\r\n"],"sourceRoot":"..\\src"}